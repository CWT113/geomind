---
date: 2025-11-09 22:32:18
---



# 递归

递归（Recursion）是一种 **函数调用自身** 的编程方法。它把一个复杂问题分解为规模更小的同类问题，直到达到一个 **终止条件** 为止。



## 阶乘

::: info 递归方式求阶乘

- 阶乘的定义 $n! = 1 · 2 · 3 ··· (n - 2) · (n - 1) · n$，其中 $n$ 为自然数，当然 $0! = 1$；

- 递推关系如下：
  $$
  f(n) =
  \begin{cases}
  1, & n = 1 \\\\
  n * f(n - 1), & n > 1
  \end{cases}
  $$

:::

```java {6}
public class Factorial {
  public static int f(int n) {
    if (n == 1) {
      return 1;
    }
    return n * f(n - 1);
  }

  public static void main(String[] args) {
    int result = f(4);
    System.out.println(result); // 24
  }
}
```



## 反向打印字符串

::: info 递归反向打印字符串

用递归反向打印字符串，n 为字符在整个字符串 str 中的索引位置。其中：

- 递：n 从 0 开始，每次 n + 1，一直递归到 n == str.length() - 1；

- 归：从 n == str.length() 开始归，从归打印，顺序就是倒序的；

- 递推关系：
  $$
  f(n) =
  \begin{cases}
  停止, & n = str.length() \\\\
  f(n + 1), & 0 <= n <= str.length() - 1
  \end{cases}
  $$

:::

```java {7}
public class ReversePrintString {
  public static void f(int n, String str) {
    if (n == str.length()) {
      return;
    }
    // 每次取字符串的第 n 个字符，然后进行输出
    f(n + 1, str);
    System.out.println(str.charAt(n));
  }

  public static void main(String[] args) {
    f(0, "abcd");
  }
}
```



## 递归二分查找

> [!TIP] 提示
>
> 递归二分查找就是用递归的方式，替换之前二分查找通过 `while` 循环来不断缩小 $i$ 和 $j$ 的过程。

```java {15,18}
public class E03BinarySearch {
  public static int search(int[] a, int target) {
    return f(a, target, 0, a.length - 1);
  }

  private static int f(int[] a, int target, int i, int j) {
    // 终止条件
    if (i > j) {
      return -1;
    }

    int m = (i + j) >>> 1;
    if (target < a[m]) {
      // 左半边，j减小，继续递归判断
      return f(a, target, i, m - 1);
    } else if (a[m] < target) {
      // 右半边，i增加，继续递归判断
      return f(a, target, m + 1, j);
    } else {
      return m;
    }
  }
}
```



## 递归冒泡排序

> [!TIP] 提示
>
> 代码中的 `x` 起到一个计数的作用，每次发生交换时，就把 `i` 的值赋值给 `x` ，一轮循环结束后，`x` 的右侧就表示已排好序，左侧表示可能还存在未排好序的值。

```java {7,15,19,10}
public class E04BubbleSort {
  private static void bubble(int[] a, int j) { // j表示数组要排序的右边界
    if (j == 0) {
      return;
    }

    int x = 0;
    for (int i = 0; i < j; i++) {
      // 从第 i 个 和 第 i+1 个比较，然后交换顺序
      if (a[i] > a[i + 1]) {
        int temp = a[i];
        a[i] = a[i + 1];
        a[i + 1] = temp;
        // 只要发生了交换，就把 i 的值赋值给 x，此时 x 就是已排好序和有可能乱序的分界线
        x = i;
      }
    }
    // x 是分界线，所以下次直接右边界设置为 x，因此 x 右侧已经是排好序的了
    bubble(a, x);
  }

  public static void main(String[] args) {
    int[] array = {2, 3, 1, 5, 6, 4, 7};
    bubble(array, array.length - 1);
    System.out.println(Arrays.toString(array));
  }
}
```



## 递归插入排序











