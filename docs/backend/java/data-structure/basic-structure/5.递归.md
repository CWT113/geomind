---
date: 2025-11-09 22:32:18
---



# 递归

递归（Recursion）是一种 **函数调用自身** 的编程方法。它把一个复杂问题分解为规模更小的同类问题，直到达到一个 **终止条件** 为止。



## 求阶乘

::: info 递归方式求阶乘

- 阶乘的定义 $n! = 1 · 2 · 3 ··· (n - 2) · (n - 1) · n$，其中 $n$ 为自然数，当然 $0! = 1$；

- 递推关系如下：
  $$
  f(n) =
  \begin{cases}
  1, & n = 1 \\\\
  n * f(n - 1), & n > 1
  \end{cases}
  $$

:::

```java {6}
public class Factorial {
  public static int f(int n) {
    if (n == 1) {
      return 1;
    }
    return n * f(n - 1);
  }

  public static void main(String[] args) {
    int result = f(4);
    System.out.println(result); // 24
  }
}
```



## 反向打印字符串

::: info 递归反向打印字符串

用递归反向打印字符串，n 为字符在整个字符串 str 中的索引位置。其中：

- 递：n 从 0 开始，每次 n + 1，一直递归到 n == str.length() - 1；

- 归：从 n == str.length() 开始归，从归打印，顺序就是倒序的；

- 递推关系：
  $$
  f(n) =
  \begin{cases}
  停止, & n = str.length() \\\\
  f(n + 1), & 0 <= n <= str.length() - 1
  \end{cases}
  $$

:::

```java {7}
public class ReversePrintString {
  public static void f(int n, String str) {
    if (n == str.length()) {
      return;
    }
    // 每次取字符串的第 n 个字符，然后进行输出
    f(n + 1, str);
    System.out.println(str.charAt(n));
  }

  public static void main(String[] args) {
    f(0, "abcd");
  }
}
```



## 二分查找

> [!TIP] 提示
>
> 递归二分查找就是用递归的方式，替换之前二分查找通过 `while` 循环来不断缩小 $i$ 和 $j$ 的过程。

```java {15,18}
public class E03BinarySearch {
  public static int search(int[] a, int target) {
    return f(a, target, 0, a.length - 1);
  }

  private static int f(int[] a, int target, int i, int j) {
    // 终止条件
    if (i > j) {
      return -1;
    }

    int m = (i + j) >>> 1;
    if (target < a[m]) {
      // 左半边，j减小，继续递归判断
      return f(a, target, i, m - 1);
    } else if (a[m] < target) {
      // 右半边，i增加，继续递归判断
      return f(a, target, m + 1, j);
    } else {
      return m;
    }
  }
}
```



## 冒泡排序

> [!TIP] 提示
>
> 代码中的 `x` 起到一个计数的作用，每次发生交换时，就把 `i` 的值赋值给 `x` ，一轮循环结束后，`x` 的右侧就表示已排好序，左侧表示可能还存在未排好序的值。

```java {7,15,19,10}
public class E04BubbleSort {
  private static void bubble(int[] a, int j) { // j表示数组要排序的右边界
    if (j == 0) {
      return;
    }

    int x = 0;
    for (int i = 0; i < j; i++) {
      // 从第 i 个 和 第 i+1 个比较，然后交换顺序
      if (a[i] > a[i + 1]) {
        int temp = a[i];
        a[i] = a[i + 1];
        a[i + 1] = temp;
        // 只要发生了交换，就把 i 的值赋值给 x，此时 x 就是已排好序和有可能乱序的分界线
        x = i;
      }
    }
    // x 是分界线，所以下次直接右边界设置为 x，因此 x 右侧已经是排好序的了
    bubble(a, x);
  }

  public static void main(String[] args) {
    int[] array = {2, 3, 1, 5, 6, 4, 7};
    bubble(array, array.length - 1);
    System.out.println(Arrays.toString(array));
  }
}
```



## 插入排序

> [!IMPORTANT] 重要
>
> 插入排序的内容听的不是太懂，多看几次！
>
> 视频连接地址：https://www.bilibili.com/video/BV1Lv4y1e7HL?t = 1.4&p = 50

```java {30}
public class E05InsertionSort {
  public static void sort(int[] a) {
    insertion(a, 1);
  }

  /**
   * 递归函数
   * @param a   数组
   * @param low 已排好序的左边界
   */
  private static void insertion(int[] a, int low) {
    if (low == a.length) {
      return;
    }

    // 把左边界 low 的值存储起来
    int value = a[low]; // 4
    // low - 1 = 0，表示数组中的第一个元素默认认为它是拍好序的
    int i = low - 1; // 0

    while (i >= 0 && a[i] > value) {
      a[i + 1] = a[i];
      i--;
    }
    if (i + 1 != low) {
      // 退出循环的时候，就表示 i 处的值比 value 要小，所以 value 插入到 i + 1 的位置
      a[i + 1] = value;
    }

    insertion(a, low + 1);
  }

  public static void main(String[] args) {
    int[] a = {2, 4, 5, 10, 7, 1};
    sort(a);
    System.out.println(Arrays.toString(a));
  }
}
```



## 斐波那契数列

>之前的例子中，每个递归函数中只包含了一个自身的调用，这种称之为 **单路递归**。而像下面的递归求斐波那契数列中，递归函数被自身调用了两次，这种称之为 **多路递归**。

::: info 递归求斐波那契数列

递归关系：
$$
f(n) =
\begin{cases}
0 & n = 0 \\\\
1 & n = 1 \\\\
f(n - 1) + f(n + 1) & n > 1
\end{cases}
$$
下面表格列出了数列的前几项：

![image-20251110221545276](assets/2025-11-10_22-15-45.png)

:::

```java
public class E06Fibonacci {
  public static int f(int n) {
    if (n == 0) {
      return 0;
    }
    if (n == 1) {
      return 1;
    }

    int x = f(n - 1);
    int y = f(n - 2);
    return x + y;
  }

  public static void main(String[] args) {
    int f = f(6);
    System.out.println("f = " + f); // 8
  }
}
```



### 记忆法优化

记忆法（Memoization）是一种通过 **存储已计算结果的优化技术**，避免重复计算相同子问题。它主要用于优化递归算法，特别是具有重叠子问题特性的算法。

::: code-group

```java [参数方式] {4,13,19}
public class E06Fibonacci {
  public static int fibonacci(int n) {
    // 缓存数组，大小为 n+1，因为存储从0到n的所有结果
    int[] cache = new int[n + 1]; 
    Arrays.fill(cache, -1); // 数组元素填充为-1，如果
    cache[0] = 0;
    cache[1] = 1;
    return f1(n, cache);
  }

  public static int f1(int n, int[] cache) {
    // 如果结果已经计算过，直接返回缓存值
    if (cache[n] != -1) {
      return cache[n];
    }
    int x = f1(n - 1, cache);
    int y = f1(n - 2, cache);
    // 将计算结果存入缓存，供后续使用（n正好就是数组的第n项）
    cache[n] = x + y;
    return cache[n];
  }

  public static void main(String[] args) {
    int f = fibonacci(5);
    System.out.println(f); // 5
  }
}
```

```java [静态方式]
public class E06Fibonacci2 {
  // 静态缓存，全局使用同一个数组
  private static int[] cache = null;

  public static int fibonacci(int n) {
    if (cache == null) {
      cache = new int[n + 1];
      Arrays.fill(cache, -1);
      cache[0] = 0;
      cache[1] = 1;
    }

    if (cache[n] != -1) {
      return cache[n];
    }

    int x = fibonacci(n - 1);
    int y = fibonacci(n - 2);
    cache[n] = x + y;
    return cache[n];
  }

  public static void main(String[] args) {
    int f = fibonacci(5);
    System.out.println(f); // 5
  }
}
```

:::









































