---
date: 2025-11-19
---



# 队列

队列（Queue）是数据结构中一种 **特殊的线性表**，它遵循“**先进先出**”的原则。

特殊地，队列只允许在表的前端（队头）进行删除操作，在表的后端（队尾）进行插入操作。队列中没有元素时，称为空队列。

> [!NOTE] 队列的优势
>
> - **保证顺序性**：队列遵循先进先出，天然适合需要按顺序处理数据的场景；
> - **操作高效**：入队和出队操作都只涉及队尾和队头，通常时间复杂度为 $O(1)$；
> - **节省空间**：链式队列根据需要动态分配内存，不像顺序队列那样容易数组容量溢出或浪费；
> - **支持异步和流式处理**：队列可作为缓存或消息中间件，在分布式系统、异步任务处理等场景实用；

| ![入队](./assets/2025-11-19_15-18-07.gif) | ![出队](./assets/2025-11-19_15-18-08.gif) |
| :---------------------------------------: | :---------------------------------------: |





## 环形链表实现

使用环形链表实现队列的好处在于可提升操作的灵活度和稳定性，尤其在需要 **频繁在队头、队尾增删元素** 的场景。

> [!NOTE] 优势
>
> - **时间复杂度低**：队头队尾操作只需要维护 `head` 和 `tail`，时间复杂度都能做到 $O(1)$；
> - **扩容成本为零**：不像顺序队列（数组实现）可能需要扩容、搬迁数据，链表天然动态扩展，无需重新开辟更大的空间；
> - **避免“假溢出问题”**：基于数组的队列在未循环处理时，会出现前面空间空闲但无法写入的情况，而链表不会；
> - **可稳定地处理大数据量**：大数据场景下，链表不会因为一次扩容而导致卡顿，而数组扩容成本高且不稳定；



::: code-group

```java [LinkedListQueue] {29,42,57,65,70}
public class LinkedListQueue<E> implements Queue<E>, Iterable<E> {
  // 节点类
  private static class Node<E> {
    E value;
    Node<E> next;

    public Node(E value, Node<E> next) {
      this.value = value;
      this.next = next;
    }
  }

  private Node<E> head = new Node<>(null, null); // 哨兵节点
  private Node<E> tail = head; // 尾节点
  private int size = 0; // 队列当前数量
  private int capacity = Integer.MAX_VALUE; // 队列最大容量

  public LinkedListQueue() {
    // 默认尾节点指向头节点
    tail.next = head;
  }

  public LinkedListQueue(int capacity) {
    this.capacity = capacity;
    tail.next = head;
  }

  @Override
  public boolean offer(E value) {
    // 队列已经满了，直接返回 false
    if (isFull()) {
      return false;
    }
    Node<E> added = new Node<>(value, head);
    tail.next = added;
    tail = added;
    size++;
    return true;
  }

  @Override
  public E poll() {
    if (isEmpty()) {
      return null;
    }
    Node<E> first = head.next;
    head.next = first.next;
    // 只有一个节点时，要把尾节点指向头节点
    if (first == tail) {
      tail = head;
    }
    size--;
    return first.value;
  }

  @Override
  public E peek() {
    if (isEmpty()) {
      return null;
    }
    return head.next.value;
  }

  @Override
  public boolean isEmpty() {
    return head == tail;
  }

  @Override
  public boolean isFull() {
    return size == capacity;
  }

  @Override
  public Iterator<E> iterator() {
    return new Iterator<>() {
      Node<E> p = head.next;

      @Override
      public boolean hasNext() {
        return p != head;
      }

      @Override
      public E next() {
        E value = p.value;
        p = p.next;
        return value;
      }
    };
  }
}
```

```java [Queue]
public interface Queue<E> {
  /**
   * 向队列尾部插入值
   * @param value 待插入值
   * @return true：插入成功；false：插入失败
   */
  boolean offer(E value);

  /**
   * 从队列头获取值，并移除
   * @return 如果队列非空返回对列头值，否则返回null
   */
  E poll();

  /**
   * 从队列头获取值，不移除
   * @return 如果队列非空返回对列头值，否则返回null
   */
  E peek();

  /**
   * 检查队列是否为空
   * @return true：为空；false：不为空
   */
  boolean isEmpty();

  /**
   * 检查队列是否已满
   * @return true：已满；false：未满
   */
  boolean isFull();
}
```

```java [单元测试]
public class TestLinkedListQueue {
  @Test
  @DisplayName("测试链表队列-offer方法")
  void testOffer() {
    LinkedListQueue<Integer> queue = new LinkedListQueue<>(3);
    queue.offer(1);
    queue.offer(2);
    queue.offer(3);
    assertFalse(queue.offer(4));
    assertFalse(queue.offer(5));

    assertIterableEquals(List.of(1, 2, 3), queue);
  }

  @Test
  @DisplayName("测试链表队列-poll方法")
  void testPoll() {
    LinkedListQueue<Integer> queue = new LinkedListQueue<>(3);
    assertNull(queue.poll());

    queue.offer(1);
    queue.offer(2);
    queue.offer(3);
    assertEquals(1, queue.poll());
    assertEquals(2, queue.poll());
    assertEquals(3, queue.poll());

    assertNull(queue.poll());
  }

  @Test
  @DisplayName("测试链表队列-peek方法")
  void testPeek() {
    LinkedListQueue<Integer> queue = new LinkedListQueue<>(3);
    assertNull(queue.peek());

    queue.offer(1);
    queue.offer(2);
    queue.offer(3);
    assertEquals(1, queue.peek());
    assertEquals(1, queue.peek());
  }

  @Test
  @DisplayName("测试链表队列-isEmpty方法")
  void testIsEmpty() {
    LinkedListQueue<Integer> queue = new LinkedListQueue<>(1);
    assertTrue(queue.isEmpty());

    queue.offer(1);
    assertFalse(queue.isEmpty());
  }

  @Test
  @DisplayName("测试链表队列-isFull方法")
  void testIsFull() {
    LinkedListQueue<Integer> queue = new LinkedListQueue<>(1);
    assertFalse(queue.isFull());

    queue.offer(1);
    assertTrue(queue.isFull());
  }

  @Test
  @DisplayName("测试链表队列-iterator方法")
  void testIterator() {
    LinkedListQueue<Integer> queue = new LinkedListQueue<>(3);
    queue.offer(1);
    queue.offer(2);
    queue.offer(3);

    for (Integer value : queue) {
      System.out.println(value);
    }
  }
}
```

:::



## 环形数组实现







## 二叉树层序遍历















