# 数组

在计算机科学中，数组是由 **一组相同类型的元素（值或变量）组成的数据结构**，每个元素至少有一个索引（键）来标识。



## 计算元素地址

因为数组内的元素是 **连续存储**（即元素索引不会间断） 的，所以数组中元素的地址，可以通过其索引计算出来。

设数组的数据起始地址是 $BaseAddress$，则计算公式为：
$$
索引 i 的地址 = BaseAddress + i * size
$$
其中：

- $i$ 表示索引，从 0 开始计算；
- $size$ 是每个元素占用的字节，例如 int 类型占用 4 个字节，double 占用 8 个字节；



```java
// 假设元素 1 的地址为 b，则元素 2 的地址为 b + 4，元素 3 的地址为 b + 8
int[] arr = {1, 2, 3, 4, 5};
```



## 动态数组

动态数组是一种可以在运行时 **自动调整大小的顺序存储结构**。它解决了普通数组长度固定、扩容困难的问题。



### 插入

::: code-group

```java [DynamicArray] {13,16}
public class DynamicArray {
  private int size = 0; // 逻辑大小
  private final int capacity = 8; // 初始容量
  private final int[] array = new int[capacity];

  public void addLast(int element) {
    add(size, element);
  }

  public void add(int index, int element) {
    if (index >= 0 && index < size) {
      // 数组从 index 开始，向右进行拷贝
      System.arraycopy(array, index, array, index + 1, size - index);
    }
    // 当 index == size 时，就是往末尾插入
    array[index] = element;
    size++;
  }

  public int get(int index) {
    if (index >= 0 && index < size) {
      return array[index];
    }
    // index 不在范围内，抛出索引越界的异常
    throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
  }
}
```

```java [单元测试]
@Test
@DisplayName("测试动态数组-插入")
void testAdd() {
  DynamicArray array = new DynamicArray();
  array.addLast(1);
  array.addLast(2);
  array.addLast(3);
  array.addLast(4);
  array.add(2, 5);

  for (int i = 0; i < 5; i++) {
    System.out.println(array.get(i));
  }
}
```

:::



### 遍历

> [!NOTE] 动态数组遍历一共有 3 种方式
>
> - 普通遍历
> - `Iterable<T>` 迭代器遍历
> - `Stream` 流遍历



::: code-group

```java [普通遍历] {12}
public class DynamicArray {
  private int size = 0; // 逻辑大小
  private final int capacity = 8; // 初始容量
  private final int[] array = new int[capacity];

  /**
   * 普通遍历
   * @param consumer 匿名函数
   */
  public void foreach(Consumer<Integer> consumer) {
    for (int i = 0; i < size; i++) {
      consumer.accept(array[i]);
    }
  }
}
```

```java [迭代器遍历] {1,17,22}
public class DynamicArray implements Iterable<Integer> {
  private int size = 0; // 逻辑大小
  private final int capacity = 8; // 初始容量
  private final int[] array = new int[capacity];

  /**
   * 迭代器遍历
   * @return 迭代器对象
   */
  @Override
  public Iterator<Integer> iterator() {
    return new Iterator<>() {
      int index = 0;

      @Override
      public boolean hasNext() {
        return index < size; // 如果 index 小于 size，表示还有下一个元素，则返回 true
      }

      @Override
      public Integer next() {
        return array[index++]; // 如果有下一个元素，则返回元素
      }
    };
  }
}
```

```java [流式遍历] {12}
public class DynamicArray {
  private int size = 0; // 逻辑大小
  private final int capacity = 8; // 初始容量
  private final int[] array = new int[capacity];

  /**
   * 流式遍历
   * @return IntStream流
   */
  public IntStream stream() {
    // IntStream.of() 接收一个数组，但是这里需要传入数组内有效的元素
    return IntStream.of(Arrays.copyOfRange(array, 0, size));
    
    // return IntStream.of(array); // 假设插入了4个元素，则剩余的4个元素默认值为0，也就是无效元素
  }
}
```

```java [单元测试]
@Test
@DisplayName("测试动态数组-遍历")
void testForeach() {
  DynamicArray array = new DynamicArray();
  array.addLast(1);
  array.addLast(2);
  array.addLast(3);
  array.addLast(4);

  array.foreach((element) -> {
    System.out.println(element);
  });
}

@Test
@DisplayName("测试动态数组-Iterable遍历")
void testIterable() {
  DynamicArray array = new DynamicArray();
  array.addLast(1);
  array.addLast(2);
  array.addLast(3);
  array.addLast(4);

  for (Integer element : array) {
    System.out.println(element);
  }
}

@Test
@DisplayName("测试动态数组-流式遍历")
void testStream() {
  DynamicArray array = new DynamicArray();
  array.addLast(1);
  array.addLast(2);
  array.addLast(3);
  array.addLast(4);

  array.stream().forEach((element) -> {
    System.out.println(element);
  });
}
```

:::



### 删除





### 扩容





## 二维数组







## 缓存与局部性原理































