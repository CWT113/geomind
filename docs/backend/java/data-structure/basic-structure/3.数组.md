---
date: 2025-11-3 18:30:00
---

# 数组

在计算机科学中，数组是由 **一组相同类型的元素（值或变量）组成的数据结构**，每个元素至少有一个索引（键）来标识。

## 计算元素地址

因为数组内的元素是 **连续存储**（即元素索引不会间断） 的，所以数组中元素的地址，可以通过其索引计算出来。

设数组的数据起始地址是 $BaseAddress$，则计算公式为：
$$
索引 i 的地址 = BaseAddress + i * size
$$
其中：

- $i$ 表示索引，从 0 开始计算；
- $size$ 是每个元素占用的字节，例如 int 类型占用 4 个字节，double 占用 8 个字节；

```java
// 假设元素 1 的地址为 b，则元素 2 的地址为 b + 4，元素 3 的地址为 b + 8
int[] arr = {1, 2, 3, 4, 5};
```

## 动态数组

动态数组是一种可以在运行时 **自动调整大小的顺序存储结构**。它解决了普通数组长度固定、扩容困难的问题。

### 插入

> [!NOTE] 时间复杂度
>
> - 头部位置 或 中间位置 插入，时间复杂度都是 $O(n)$（因为涉及到数组元素的移动）；
> - 尾部位置插入，时间复杂度是 $O(1)$；

::: code-group

```java [DynamicArray] {13,16}
public class DynamicArray {
  private int size = 0; // 逻辑大小
  private int capacity = 8; // 初始容量
  private int[] array = new int[capacity];

  public void addLast(int element) {
    add(size, element);
  }

  public void add(int index, int element) {
    if (index >= 0 && index < size) {
      // 数组从 index 开始，向右进行拷贝
      System.arraycopy(array, index, array, index + 1, size - index);
    }
    // 当 index == size 时，就是往末尾插入
    array[index] = element;
    size++;
  }

  public int get(int index) {
    if (index >= 0 && index < size) {
      return array[index];
    }
    // index 不在范围内，抛出索引越界的异常
    throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
  }
}
```

```java [单元测试]
@Test
@DisplayName("测试动态数组-插入")
void testAdd() {
  DynamicArray array = new DynamicArray();
  array.addLast(1);
  array.addLast(2);
  array.addLast(3);
  array.addLast(4);
  array.add(2, 5);

  for (int i = 0; i < 5; i++) {
    System.out.println(array.get(i));
  }
}
```

:::

### 遍历

> [!NOTE] 动态数组遍历的 3 种方式
>
> - 普通遍历
> - `Iterable<T>` 迭代器遍历
> - `Stream` 流遍历

::: code-group

```java [普通遍历] {12}
public class DynamicArray {
  private int size = 0; // 逻辑大小
  private int capacity = 8; // 初始容量
  private int[] array = new int[capacity];

  /**
   * 普通遍历
   * @param consumer 匿名函数
   */
  public void foreach(Consumer<Integer> consumer) {
    for (int i = 0; i < size; i++) {
      consumer.accept(array[i]);
    }
  }
}
```

```java [迭代器遍历] {1,17,22}
public class DynamicArray implements Iterable<Integer> {
  private int size = 0; // 逻辑大小
  private int capacity = 8; // 初始容量
  private int[] array = new int[capacity];

  /**
   * 迭代器遍历
   * @return 迭代器对象
   */
  @Override
  public Iterator<Integer> iterator() {
    return new Iterator<>() {
      int index = 0;

      @Override
      public boolean hasNext() {
        return index < size; // 如果 index 小于 size，表示还有下一个元素，则返回 true
      }

      @Override
      public Integer next() {
        return array[index++]; // 如果有下一个元素，则返回元素
      }
    };
  }
}
```

```java [流式遍历] {12}
public class DynamicArray {
  private int size = 0; // 逻辑大小
  private int capacity = 8; // 初始容量
  private int[] array = new int[capacity];

  /**
   * 流式遍历
   * @return IntStream流
   */
  public IntStream stream() {
    // IntStream.of() 接收一个数组，但是这里需要传入数组内有效的元素
    return IntStream.of(Arrays.copyOfRange(array, 0, size));
    
    // return IntStream.of(array); // 假设插入了4个元素，则剩余的4个元素默认值为0，也就是无效元素
  }
}
```

```java [单元测试]
@Test
@DisplayName("测试动态数组-遍历")
void testForeach() {
  DynamicArray array = new DynamicArray();
  array.addLast(1);
  array.addLast(2);
  array.addLast(3);
  array.addLast(4);

  array.foreach((element) -> {
    System.out.println(element);
  });
}

@Test
@DisplayName("测试动态数组-Iterable遍历")
void testIterable() {
  DynamicArray array = new DynamicArray();
  array.addLast(1);
  array.addLast(2);
  array.addLast(3);
  array.addLast(4);

  for (Integer element : array) {
    System.out.println(element);
  }
}

@Test
@DisplayName("测试动态数组-流式遍历")
void testStream() {
  DynamicArray array = new DynamicArray();
  array.addLast(1);
  array.addLast(2);
  array.addLast(3);
  array.addLast(4);

  array.stream().forEach((element) -> {
    System.out.println(element);
  });
}
```

:::

### 删除

::: code-group

```java [DynamicArray] {11,13}
public class DynamicArray {
  private int size = 0;
  private int capacity = 8;
  private int[] array = new int[capacity];

  public int remove(int index) {
    if (index >= 0 && index < size) {
      int removed = array[index];
      // 如果移除的就是最后一个元素，则直接size--即可，不用拷贝数组
      if (index < size - 1) {
        System.arraycopy(array, index + 1, array, index, size - index - 1);
      }
      size--;
      return removed;
    }
    throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
  }
}
```

```java [单元测试]
@Test
@DisplayName("测试动态数组-删除元素")
void testRemove() {
  DynamicArray array = new DynamicArray();
  array.addLast(1);
  array.addLast(2);
  array.addLast(3);
  array.addLast(4);
  array.addLast(5);

  int removed = array.remove(2);
  assertEquals(3, removed);
  // 集合断言
  assertIterableEquals(List.of(1, 2, 4, 5), array);
}
```

:::

### 扩容

> [!TIP] 提示
>
>下面代码中，将 `array` 数组默认赋值为 `{}` 空数组，是一种 **懒惰化** 的思想，只在使用到数组的时候，才进行容量赋值，以节省内存空间。

```java {12-20}
public class DynamicArray {
  private int size = 0;
  private int capacity = 8;
  private int[] array = {}; // 空数组 // [!code ++]

  public void addLast(int element) {
    add(size, element);
  }

  public void add(int index, int element) {
    // 容量扩容
    if (size == 0) {
      array = new int[capacity];
    } else if (size == capacity) {
      capacity = capacity + (capacity >> 1); // 扩容1.5倍
      int[] newArray = new int[capacity];
      // 旧数组中的元素都拷贝到新数组中
      System.arraycopy(array, 0, newArray, 0, size);
      array = newArray;
    }

    if (index >= 0 && index < size) {
      System.arraycopy(array, index, array, index + 1, size - index);
    }
    array[index] = element;
    size++;
  }
}
```
