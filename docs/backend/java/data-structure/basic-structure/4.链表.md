---
date: 2025-11-05 18:30:00
---

# 链表

链表（Linked List）是一种 **线性数据结构**，由一系列的 **节点** 组成。每个节点包含两部分：

- **数据域**（Data）：存储实际数据；
- **指针域**（Pointer）：存储指向下一个节点的引用地址；

链表通过“指针”把分散在内存中的节点连接起来，因此不需要像数组那样要求连续的内存空间。

> [!NOTE] 链表的特点
>
> - 优点：插入、删除效率高（时间复杂度为 $O(1)$，只需要修改指针）；
> - 缺点：查询效率低（时间复杂度为 $O(n)$，必须从头遍历查找）；
> - 用途：适用于频繁插入/删除操作的场景，如队列、栈、哈希表底层等；



## 单向链表

单向链表的每个节点只指向下一个节点，尾节点指向 `null`。单向链表只能从头到尾遍历。

![2025-11-04_23-28-33](./assets/2025-11-04_23-28-33.png)

### 插入

::: code-group

```java [addFirst] {17}
public class SinglyLinkedList  {
  // 头指针
  private Node head = null;

  // 节点类
  private static class Node {
    int value;
    Node next;

    public Node(int value, Node next) {
      this.value = value;
      this.next = next;
    }
  }

  public void addFirst(int value) {
    head = new Node(value, head);
  }
}
```

```java [addLast] {21,22,26}
public class SinglyLinkedList {
  private Node head = null;

  private static class Node {
    int value;
    Node next;

    public Node(int value, Node next) {
      this.value = value;
      this.next = next;
    }
  }

  public void addFirst(int value) {
    head = new Node(value, head);
  }

  public void addLast(int value) {
    Node last = findLast();
    // 如果 last 为空，表示空链表，则按照 addFirst 添加即可
    if (last == null) {
      addFirst(value);
      return;
    }
    // 如果 last 不为空，则让 last.next 指向新节点
    last.next = new Node(value, null);
  }

  private Node findLast() {
    // head 为空表示是个空链表
    if (head == null) return null;
    // 遍历获取最后一个节点
    Node p;
    for (p = head; p.next != null; p = p.next) {
    }
    return p;
  }
}
```

```java [按索引插入] {35,40}
public class SinglyLinkedList {
  private Node head = null;

  private static class Node {
    int value;
    Node next;

    public Node(int value, Node next) {
      this.value = value;
      this.next = next;
    }
  }

  public void addFirst(int value) {
    head = new Node(value, head);
  }

  private Node findNode(int index) {
    int i = 0;
    for (Node p = head; p.next != null; p = p.next, i++) {
      if (i == index) {
        return p;
      }
    }
    return null;
  }

  public void insert(int index, int value) {
    // 第一个节点，直接使用 addFirst 添加即可
    if (index == 0) {
      addFirst(value);
      return;
    }
    // 找到上一个节点
    Node prev = findNode(index - 1);
    if (prev == null) {
      throw new IllegalThreadStateException(String.format("index [%d] 不合法", index));
    }
    // 当前节点指向的下一个节点，就是 prev 的下一个节点，它俩指向同一个
    prev.next = new Node(value, prev.next);
  }
}
```

:::



### 查询

::: code-group

```java [get] {16,25-31}
public class SinglyLinkedList {
  private Node head = null;

  private static class Node {
    int value;
    Node next;

    public Node(int value, Node next) {
      this.value = value;
      this.next = next;
    }
  }

  private Node findNode(int index) {
    int i = 0;
    for (Node p = head; p != null; p = p.next, i++) { // for循环的最后一个条件可以用 , 号写多个
      // 如果 i 计数和 index 相同了，就表示找到了节点
      if (i == index) {
        return p;
      }
    }
    return null;
  }

  public int get(int index) {
    Node node = findNode(index);
    if (node == null) {
      throw new IllegalThreadStateException(String.format("index [%d] 不合法", index));
    }
    return node.value;
  }
}
```

```java [单元测试]
@Test
@DisplayName("测试链表获取")
void testGet() {
  SinglyLinkedList list = new SinglyLinkedList();
  list.addLast(1);
  list.addLast(2);
  list.addLast(3);
  list.addLast(4);

  assertEquals(3, list.get(2));
}
```

:::



### 遍历

::: code-group

```java [while循环]
public class SinglyLinkedList {
  private Node head = null;

  private static class Node {
    int value;
    Node next;

    public Node(int value, Node next) {
      this.value = value;
      this.next = next;
    }
  }

  public void loop1(Consumer<Integer> consumer) {
    Node p = head;
    while (p != null) {
      consumer.accept(p.value);
      p = p.next; // 指针右移
    }
  }
}
```

```java [for循环] {15}
public class SinglyLinkedList {
  private Node head = null;

  private static class Node {
    int value;
    Node next;

    public Node(int value, Node next) {
      this.value = value;
      this.next = next;
    }
  }

  public void loop2(Consumer<Integer> consumer) {
    for (Node p = head; p != null; p = p.next) {
      consumer.accept(p.value);
    }
  }
}
```

```java [迭代器循环] {1}
public class SinglyLinkedList implements Iterable<Integer> {
  private Node head = null;

  private static class Node {
    int value;
    Node next;

    public Node(int value, Node next) {
      this.value = value;
      this.next = next;
    }
  }

  // 实现 Iterable 接口的方法
  @Override
  public Iterator<Integer> iterator() {
    return new Iterator<>() {
      Node p = head;

      @Override
      public boolean hasNext() {
        return p != null;
      }

      @Override
      public Integer next() {
        int v = p.value;
        p = p.next;
        return v;
      }
    };
  }
}
```

```java [单元测试]
@Test
@DisplayName("测试单向链表")
void test() {
  SinglyLinkedList list = new SinglyLinkedList();
  list.addFirst(1);
  list.addFirst(2);
  list.addFirst(3);
  list.addFirst(4);

  // while循环
  list.loop1(element -> {
    System.out.println(element);
  });

  // for循环（lambda简化写法）
  list.loop2(System.out::println);

  // 迭代器循环
  for (Integer value : list) {
    System.out.println(value);
  }
}
```

:::



### 删除

> [!tip] 提示
>
> 删除掉的元素在 Java 中是会被垃圾回收机制自动回收的，但是在其他语言中可能需要手动回收哦！

::: code-group

```java [removeFirst] {19}
public class SinglyLinkedList {
  private Node head = null;

  private static class Node {
    int value;
    Node next;

    public Node(int value, Node next) {
      this.value = value;
      this.next = next;
    }
  }

  public void removeFirst() {
    if (head == null) {
      throw new IllegalThreadStateException(String.format("index [%d] 不合法", 0));
    }
    // 当前的 head 直接替换为下一个节点
    head = head.next;
  }
}
```

```java [按索引删除] {21,26,30}
public class SinglyLinkedList {
  private Node head = null;

  private static class Node {
    int value;
    Node next;

    public Node(int value, Node next) {
      this.value = value;
      this.next = next;
    }
  }

  public void remove(int index) {
    // 如果删除的是第一个节点
    if (index == 0) {
      removeFirst();
      return;
    }
    // 获取当前索引的上一个节点
    Node prev = findNode(index - 1);
    if (prev == null) {
      throw new IllegalThreadStateException(String.format("index [%d] 不合法", index));
    }
    // 上一个节点的 next 指向的就是要删除的节点
    Node removed = prev.next;
    if (removed == null) {
      throw new IllegalThreadStateException(String.format("index [%d] 不合法", index));
    }
    prev.next = removed.next;
  }
}
```

:::



### 带哨兵链表

::: info 哨兵节点

链表内还有一种特殊的节点成为 **哨兵节点**（或哑元节点），它不存储数据，通常用在链表头尾，用于简化边界判断。

![2025-11-04_23-33-20](./assets/2025-11-04_23-33-20.png)

:::

```java
public class SinglyLinkedListSentinel implements Iterable<Integer> {
  private final Node head = new Node(666, null); // 哨兵节点

  /**
   * 节点类
   */
  private static class Node {
    int value;
    Node next;

    public Node(int value, Node next) {
      this.value = value;
      this.next = next;
    }
  }

  /**
   * 头部添加节点
   * @param value 节点值
   */
  public void addFirst(int value) {
    insert(0, value);
  }

  /**
   * 尾部添加节点
   * @param value 节点值
   */
  public void addLast(int value) {
    // 默认的最后一个节点就是 head 哨兵节点，无需判断 last 为空
    Node last = findLast();
    last.next = new Node(value, null);
  }

  /**
   * 按索引插入节点
   * @param index 索引
   * @param value 值
   */
  public void insert(int index, int value) {
    Node prev = findNode(index - 1);
    if (prev == null) {
      throw new IllegalThreadStateException(String.format("index [%d] 超出了链表范围.", index));
    }
    prev.next = new Node(value, prev.next);
  }

  /**
   * 链表 while 遍历
   * @param consumer 操作函数
   */
  public void loop1(Consumer<Integer> consumer) {
    Node p = head.next;
    while (p != null) {
      consumer.accept(p.value);
      p = p.next;
    }
  }

  /**
   * 链表 for 遍历
   * @param consumer 操作函数
   */
  public void loop2(Consumer<Integer> consumer) {
    for (Node p = head.next; p != null; p = p.next) {
      consumer.accept(p.value);
    }
  }

  /**
   * 迭代器遍历
   * @return 迭代器对象
   */
  @Override
  public Iterator<Integer> iterator() {
    return new Iterator<>() {
      // 从哨兵节点的下一个节点开始遍历
      Node p = head.next;

      @Override
      public boolean hasNext() {
        return p != null;
      }

      @Override
      public Integer next() {
        int v = p.value;
        p = p.next;
        return v;
      }
    };
  }

  /**
   * 按索引查找链表节点
   * @param index 索引
   * @return 当前索引处的链表节点
   */
  public int get(int index) {
    Node node = findNode(index);
    if (node == null) {
      throw new IllegalThreadStateException(String.format("index [%d] 超出了链表范围.", index));
    }
    return node.value;
  }

  /**
   * 删除链表头部节点
   */
  public void removeFirst() {
    remove(0);
  }

  /**
   * 按索引删除链表节点
   * @param index 索引
   */
  public void remove(int index) {
    Node prev = findNode(index - 1);
    if (prev == null) {
      throw new IllegalThreadStateException(String.format("index [%d] 不合法", index));
    }
    Node removed = prev.next;
    if (removed == null) {
      throw new IllegalThreadStateException(String.format("index [%d] 不合法", index));
    }
    prev.next = removed.next;
  }

  /**
   * 按索引查找链表节点
   * @param index 索引
   * @return 当前索引处的链表节点
   */
  private Node findNode(int index) {
    // 从 -1 开始找，-1 代表的就是哨兵节点
    int i = -1;
    for (Node p = head; p != null; p = p.next, i++) {
      if (i == index) {
        return p;
      }
    }
    return null;
  }

  /**
   * 查找链表最后一个节点
   * @return 最后节点
   */
  private Node findLast() {
    Node p;
    for (p = head; p.next != null; p = p.next) {

    }
    return p;
  }
}
```





## 双向链表

双向链表的每个节点有两个指针：`prev`（前驱）和 `next`（后继）。可以从前向后、从后向前遍历。

![2025-11-04_23-28-49](./assets/2025-11-04_23-28-49.png)

### 带哨兵链表





## 循环链表

循环链表的最后一个节点指向第一个节点，形成闭环结构，常用于循环队列。

![2025-11-04_23-29-02](./assets/2025-11-04_23-29-02.png)



## 双向环形链表

### 带哨兵链表











