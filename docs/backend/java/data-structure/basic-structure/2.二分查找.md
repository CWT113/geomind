# 二分查找

::: info 需求

在 **有序** 数组 A 内，查找目标值 `target` ：

- 如果找到，返回索引值；
- 如果没找到，返回 `-1`；

:::



## 基础版

算法思路：

| 算法描述 | 说明                                                         |
| :------: | ------------------------------------------------------------ |
|   前提   | 给定一个内含 n 个元素的 **有序** 数组 A，及一个目标值 target |
|    1     | 设置 $i = 0, j = n - 1$                                      |
|    2     | 如果 $i > j$，结束查找，没有找到                             |
|    3     | 设置 $m = floor(\frac{i + j}{2})$，$m$ 为中间索引，$floor$ 是向下取整（<span style="color:#CC0000;">注意：取中间索引是有问题的，详见 **误区1**</span>） |
|    4     | 如果 $target < A_m$，则设置 $j = m - 1$，回到第 2 步执行     |
|    5     | 如果 $A_m < target$，则设置 $i = m + 1$，回到第 2 步执行     |
|    6     | 如果 $A_m = target$，结束查找，找到了                        |

::: code-group

```java {6,8} [版本一]
public static int binarySearchBasic(int[] arr, int target) {
  int i = 0, j = arr.length - 1;
  while (i <= j) {
    int m = (i + j) / 2; // [!code warning]
    if (target < arr[m]) { // 如果目标值小于中间值，则 j 要往前移动
      j = m - 1;
    } else if (target > arr[m]) { // 如果目标值大于中间值，则 i 要往后移动
      i = m + 1;
    } else { // 相等直接返回索引
      return m;
    }
  }
  return -1;
}
```

```java [版本二（重点）]
public static int binarySearchBasic(int[] arr, int target) {
  int i = 0, j = arr.length - 1;
  while (i <= j) {
    int m = (i + j) >>> 1; // [!code ++]
    if (target < arr[m]) {
      j = m - 1;
    } else if (target > arr[m]) {
      i = m + 1;
    } else {
      return m;
    }
  }
  return -1;
}
```

```java {2,3,6} [版本三]
public static int binarySearchAlternative(int[] arr, int target) {
  int i = 0, j = arr.length; // j不是数组长度-1了
  while (i < j) { // 这里就不能使用 <= 了
    int m = (i + j) >>> 1;
    if (target < arr[m]) {
      j = m;
    } else if (arr[m] < target) {
      i = m + 1;
    } else {
      return m;
    }
  }
  return -1;
}
```

:::

::: details 误区 1：为什么第 3 步，$m$ 的值不推荐使用 $floor(\frac{i + j}{2})$ 的方式获取？

**原因：** 当 $i$ 和 $j$ 都非常大时，并且二者相加超过了 `int` 类型能表示的最大值时，就会发生 **整数溢出**。此时 $i + j$ 的值会变成一个负数（因为最高位变成了 1，被解释为符号位了），然后再除以 2，得到的 $m$ 就是一个错误的负值。

> [!TIP]  解决方案
>
> 通过 `>>>` 无符号右移运算符，将二进制表示的所有位向右移动指定的位数，**高位补零**，正好等价于 除以 2 并向下取整的结果。

```java
@Test
void testDemo() {
  int i = Integer.MAX_VALUE / 2;
  int j = Integer.MAX_VALUE;

  int m = (i + j) / 2; // -536870913（变成了负数，因为i+j超过了int类型的最大值）
  System.out.println(m);

  int n = (i + j) >>> 1; // 1610612735（正确）
  System.out.println(n);
}
```

:::

> [!CAUTION] 基础版缺点
>
> - 当待查找元素在数组左侧时，执行了 `target < arr[m]` 判断，就不会执行后续判断；
> - 但是当待查找元素在数组右侧时，此时会执行 `target < arr[m]`，不满足条件，然后再执行 `target > arr[m]` 判断；
> - 这样导致 **左侧查找时间复杂度低，右侧查找时间复杂度高**；



## 平衡版

平衡版就是在解决 基础版 左右两侧查找时间复杂度不一致的问题。

```java {4,9}
public static int binarySearchBalance(int[] arr, int target) {
  int i = 0, j = arr.length;
  // 判断 i 和 j 之间是不是只有一个元素了
  while (1 < j - i) {
    int m = (i + j) >>> 1;
    if (target < arr[m]) {
      j = m;
    } else {
      i = m;
    }
  }
  // 当退出 while 循环时，再进行取值比较，这样无论左右两侧都只比较一次
  if (arr[i] == target) { 
    return i;
  } else {
    return -1;
  }
}
```

> [!CAUTION] 平衡版缺点
>
> - 在基础版中，如果待查找元素就是中间值，此时只需要循环一次，时间复杂度是 $O(1)$；
> - 而在平衡版中，会把整个 `while` 循环执行完成后，再进行取值比较，时间复杂度是 $O(logn)$（最好和最坏的情况，都会循环所有）；



## Java版

下面来看一下在 Java 源码中，二分查找的实现：

```java
public static int binarySearch(long[] a, long key) {
  return binarySearch0(a, 0, a.length, key);
}

private static int binarySearch0(long[] a, int fromIndex, int toIndex, long key) {
  int low = fromIndex;
  int high = toIndex - 1;

  while (low <= high) {
    int mid = (low + high) >>> 1;
    long midVal = a[mid];

    if (midVal < key)
      low = mid + 1;
    else if (midVal > key)
      high = mid - 1;
    else
      return mid;
  }
  
  return -(low + 1); // 未找到时，返回索引+1的负值 // [!code ++]
}
```































